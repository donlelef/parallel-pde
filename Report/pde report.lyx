#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\begin_preamble

\end_preamble
\use_default_options true
\begin_modules
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language british
\language_package auto
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2.5cm
\rightmargin 2cm
\bottommargin 2.5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "language=C,keywordstyle={\color{cyan}},commentstyle={\color{magenta}\itshape},emphstyle={\color{blue}},emph={int,char,double,float,unsigned},breaklines=true,basicstyle={\ttfamily},stringstyle={\color{green}},identifierstyle={\color{black}},numbers=left,numbersep=3pt,tabsize=2"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Finite Elements Methods: a parallel implementation
\end_layout

\begin_layout Author
Simone Colucci & Emanuele Fabbiani
\end_layout

\begin_layout Date
February 
\begin_inset Formula $15^{th}$
\end_inset

, 2016
\end_layout

\begin_layout Abstract
TODO
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Partial differential equations (PDE) are differential equations where the
 unknown is a multivariable function.
 Far from being just complex mathematical problems, PDE are very useful
 tools to model several different phenomena in Physics, Biology, Economics
 and Engineering.
 Maxwell's laws of Electromagnetic fields and Navier-Stokes equations for
 fluids are just two examples of major applications of PDE theory.
 However, PDEs are usually impossible to solve in closed form: numerical
 methods are required to compute approximate solutions.
 The most used methods to solve PDE numerically are known as Finite Element
 Methods.
 First introduced in the '40s FEMs utility was underestimated at the time
 because of the lack of computational power.
 Nowadays they enter the design process of planes, buildings and cars as
 a low-cost and effective alternative to real stress tests.
\end_layout

\begin_layout Subsection
The Finite Element Method
\end_layout

\begin_layout Standard
To understand how the method works, we consider an elliptic homogeneous
 equation:
\begin_inset Formula 
\begin{equation}
\begin{cases}
-\Delta u\left(x,y\right)=f\left(x,y\right) & in\:\Omega\\
u=g\left(x,y\right) & on\:\partial\Omega
\end{cases}
\end{equation}

\end_inset

where 
\begin_inset Formula $\Delta u\left(x,y\right)=\frac{\partial^{2}u\left(x,y\right)}{\partial x^{2}}+\frac{\partial^{2}u\left(x,y\right)}{\partial y^{2}}$
\end_inset

 and 
\begin_inset Formula $f:\mathbb{R}^{2}\mapsto\mathbb{R}$
\end_inset

 is a well-defined function in 
\begin_inset Formula $\Omega\in\mathbb{R}^{2}$
\end_inset

.
 FEMs are based on the weak formulation of the differential problem, so
 we have to introduce a test function 
\begin_inset Formula $v$
\end_inset

, which is supposed to be regular enough.
 We multiply the differential equation by 
\begin_inset Formula $v$
\end_inset

 and we integrate over 
\begin_inset Formula $\Omega$
\end_inset

:
\begin_inset Formula 
\begin{equation}
\int_{\Omega}\left(-\Delta u\right)v=\int_{\Omega}fv
\end{equation}

\end_inset

Then we apply the Gauss-Green formula:
\begin_inset Formula 
\begin{equation}
\int_{\Omega}\Delta uv+\int_{\Omega}\nabla u\cdot\nabla v=\int_{\partial\Omega}v\frac{\partial u}{\partial n}
\end{equation}

\end_inset

And we choose 
\begin_inset Formula $v$
\end_inset

 such that 
\begin_inset Formula $v|_{\partial\Omega}\equiv0$
\end_inset

.
 We got to the weak formulation:
\begin_inset Formula 
\begin{equation}
\int_{\Omega}\nabla u\cdot\nabla v=\int_{\partial\Omega}v\frac{\partial u}{\partial n}+\int_{\Omega}fv
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
\int_{\Omega}\nabla u\cdot\nabla v=\int_{\Omega}fv\label{eq:debole}
\end{equation}

\end_inset

This equation should hold for every 
\begin_inset Formula $v$
\end_inset

.
 Up to here, no approximation has been performed.
 Form now on, the Finite Elements approximation begins.
 We approximate the set 
\begin_inset Formula $\Omega$
\end_inset

 with the union of triangles 
\begin_inset Formula $\mathcal{T}_{h}$
\end_inset

.
\begin_inset Formula 
\begin{equation}
\Omega\simeq\bigcup_{T\in\mathcal{T}_{h}}T
\end{equation}

\end_inset

The equality holds only if 
\begin_inset Formula $\Omega$
\end_inset

 is a polygon.
 The length 
\begin_inset Formula $h$
\end_inset

 of the longest edge of a triangle 
\begin_inset Formula $T\in\mathcal{T}_{h}$
\end_inset

 is a good index about how fine the mesh is.
 Then we approximate the function 
\begin_inset Formula $u$
\end_inset

 with a new function 
\begin_inset Formula $u_{h}$
\end_inset

, which is supposed to be linear on every triangle 
\begin_inset Formula $T$
\end_inset

 and continuous on 
\begin_inset Formula $\Omega$
\end_inset

; moreover we want the test function 
\begin_inset Formula $v$
\end_inset

 to present the same features.
 To underline the restriction, 
\begin_inset Formula $v$
\end_inset

 will be called 
\begin_inset Formula $v_{h}$
\end_inset

.
 It is possible to show that the functional space 
\begin_inset Formula $u_{h}$
\end_inset

 and 
\begin_inset Formula $v_{h}$
\end_inset

 belong to has a dimension which is finite and equals the number 
\begin_inset Formula $n$
\end_inset

 of vertexes of triangles in the internal of the set 
\begin_inset Formula $\Omega$
\end_inset

.
 We define 
\begin_inset Formula $\varphi_{i}$
\end_inset

, 
\begin_inset Formula $i=1...n$
\end_inset

 a set of functions which is a basis for the functional space 
\begin_inset Formula $v$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

 belongs to:
\begin_inset Formula 
\begin{equation}
u_{h}\left(x,y\right)=\sum_{i=1}^{n}u_{i}\varphi_{i}\left(x,y\right)
\end{equation}

\end_inset

The equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:debole"

\end_inset

 is verified by every 
\begin_inset Formula $v$
\end_inset

 if and only if it holds for all the elements 
\begin_inset Formula $\varphi_{j}$
\end_inset

 in a basis of the functional space.
 We impose this condition and we get to the following linear system:
\begin_inset Formula 
\begin{equation}
\sum_{i=1}^{n}u_{i}\int_{\Omega}\nabla\varphi_{i}\cdot\nabla\varphi_{j}=\int_{\Omega}f\cdot\varphi_{j}\;\;\forall j=1...n
\end{equation}

\end_inset

We define 
\begin_inset Formula $W=\left\{ W_{i,j}\right\} =\int_{\Omega}\nabla\varphi_{i}\cdot\nabla\varphi_{j}$
\end_inset

, 
\begin_inset Formula $u=\left\{ u_{i}\right\} $
\end_inset

 and 
\begin_inset Formula $b=\left\{ b_{j}\right\} \coloneqq\int_{\Omega}f\cdot\varphi_{j}$
\end_inset

, so that we can write the system in matrix form:
\begin_inset Formula 
\begin{equation}
Wu=b
\end{equation}

\end_inset

We can exploit the linearity of the integral to ease the computation of
 
\begin_inset Formula $W$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

: we can compute the contribution on every triangle 
\begin_inset Formula $T$
\end_inset

 and then sum them up.
 We choose the easiest set of basic functions 
\begin_inset Formula $\varphi$
\end_inset

, that is the 
\begin_inset Formula $\varphi_{j}=1$
\end_inset

 on the vertex with index 
\begin_inset Formula $j$
\end_inset

 and 0 on all the others.
 The computation of the local matrix 
\begin_inset Formula $W_{T}$
\end_inset

 of the triangle 
\begin_inset Formula $T$
\end_inset

 lead to a symmetric matrix:
\begin_inset Formula 
\begin{equation}
W_{T}=\begin{bmatrix}\int_{\Omega}\nabla\varphi_{i}\cdot\nabla\varphi_{i} & \int_{\Omega}\nabla\varphi_{i}\cdot\nabla\varphi_{j} & \int_{\Omega}\nabla\varphi_{i}\cdot\nabla\varphi_{k}\\
\int_{\Omega}\nabla\varphi_{i}\cdot\nabla\varphi_{j} & \int_{\Omega}\nabla\varphi_{j}\cdot\nabla\varphi_{j} & \int_{\Omega}\nabla\varphi_{j}\cdot\nabla\varphi_{k}\\
\int_{\Omega}\nabla\varphi_{i}\cdot\nabla\varphi_{k} & \int_{\Omega}\nabla\varphi_{j}\cdot\nabla\varphi_{k} & \int_{\Omega}\nabla\varphi_{k}\cdot\nabla\varphi_{k}
\end{bmatrix}=\frac{1}{4\left|T\right|}\begin{bmatrix}l_{i}\cdot l_{i} & l_{i}\cdot l_{j} & l_{i}\cdot l_{k}\\
l_{j}\cdot l_{i} & l_{j}\cdot l_{j} & l_{j}\cdot l_{k}\\
l_{k}\cdot l_{i} & l_{k}\cdot l_{j} & l_{k}\cdot l_{k}
\end{bmatrix}
\end{equation}

\end_inset

where 
\begin_inset Formula $\left|T\right|$
\end_inset

 is the area of the triangle and 
\begin_inset Formula $l_{i}\cdot l_{j}$
\end_inset

 is the scalar product between the edges described by the vectors 
\begin_inset Formula $l_{i}$
\end_inset

 and 
\begin_inset Formula $l_{j}$
\end_inset

.
 We can compute the local right-hand side 
\begin_inset Formula $b_{T}$
\end_inset

, using some quadrature formula.
 We choose the barycentre formula, the easiest one:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
b_{T}=\begin{bmatrix}\int_{\Omega}f\cdot\varphi_{i}\\
\int_{\Omega}f\cdot\varphi_{j}\\
\int_{\Omega}f\cdot\varphi_{k}
\end{bmatrix}\simeq\frac{\left|T\right|}{3}\begin{bmatrix}f\left(x_{B},y_{B}\right)\\
f\left(x_{B},y_{B}\right)\\
f\left(x_{B},y_{B}\right)
\end{bmatrix}
\end{equation}

\end_inset

dove
\begin_inset Formula 
\begin{equation}
x_{B}=\frac{1}{3}\sum_{i=1}^{3}x_{i}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
y_{B}=\frac{1}{3}\sum_{i=1}^{3}y_{i}
\end{equation}

\end_inset

It can be proved that this formula is exact if and only if the function
 
\begin_inset Formula $f$
\end_inset

 is constant on the border of 
\begin_inset Formula $\Omega$
\end_inset

.
\end_layout

\begin_layout Subsection
Model problem
\end_layout

\begin_layout Standard
We take the following partial differential equation as a model:
\begin_inset Formula 
\begin{equation}
\begin{cases}
-\Delta u\left(x,y\right)=-4 & in\:\Omega=\left\{ \left(x,y\right)\in\mathbb{R}^{2}:x^{2}+y^{2}\leq1\right\} \\
u=1 & on\:\partial\Omega=\left\{ \left(x,y\right)\in\mathbb{R}^{2}:x^{2}+y^{2}=1\right\} 
\end{cases}
\end{equation}

\end_inset

We choose this very equation because we can deduce the true solution.
 If we try 
\begin_inset Formula 
\begin{equation}
u\left(x,y\right)=x^{2}+y^{2}
\end{equation}

\end_inset

we get:
\begin_inset Formula 
\begin{equation}
-\Delta u\left(x,y\right)=-\frac{\partial^{2}u\left(x,y\right)}{\partial x^{2}}-\frac{\partial^{2}u\left(x,y\right)}{\partial y^{2}}=-2-2=-4
\end{equation}

\end_inset

As the solution to such a problem is proved to be unique, 
\begin_inset Formula $u\left(x,y\right)$
\end_inset

 is the function we are looking for.
\end_layout

\begin_layout Section
Serial implementation
\end_layout

\begin_layout Standard
We shall consider now the actual C-language implementation of the algorithm
 that does approximate the solution of the given problem with a finite elements
 approach.
 In order to focus on the interesting parts, we will disregard I/O operations
 that are useful to the program execution but do not represent any case
 of study.
\end_layout

\begin_layout Standard
Roughly speaking, the developed code can easily be split into four parts:
 
\end_layout

\begin_layout Enumerate
Memory allocation and initialisation for both the Stiffness matrix 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $W$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 and the right-hand side 
\begin_inset Formula $b$
\end_inset

.
\end_layout

\begin_layout Enumerate
Computation of the global Stiffness matrix 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $W$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 and the global right-hand side 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $b$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 by computing and assembling up local ones.
\end_layout

\begin_layout Enumerate
Assignment of Dirichlet conditions.
\end_layout

\begin_layout Enumerate
Computation of the vector 
\begin_inset Formula $u$
\end_inset

 solution of 
\begin_inset Formula $Wu$
\end_inset


\begin_inset Formula $=b$
\end_inset

.
\end_layout

\begin_layout Subsection
Memory allocation and variable initialisation
\end_layout

\begin_layout Standard
As we stated, the very first task that the algorithm must handle is a proper
 memory dynamic allocation that allow us to store both the Stiffness matrix
 and the right-hand side.
 In order to improve memory usage and to uniform access, the matrix is indeed
 stored as a linear 1D vector.
 The function that implement this initialisation is shown below.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

double* zeros(int dim) { 	
\end_layout

\begin_layout Plain Layout

	int i = 0;
\end_layout

\begin_layout Plain Layout

	double* vector = (double*) malloc(sizeof(double) * dim); 	
\end_layout

\begin_layout Plain Layout

	for (i = 0; i < dim; i++) { 		
\end_layout

\begin_layout Plain Layout

		vector[i] = 0; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	return vector; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Memory allocation and variable initialization
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Disregarding the initial part that simply allocates required memory space,
 we notice that the initialisation actually results in 
\begin_inset Formula $n$
\end_inset

 store calls, 
\begin_inset Formula $n$
\end_inset

 being the dimension of the vector.
 In our case, that lead us to 
\begin_inset Formula $n^{2}+n$
\end_inset

 store calls, with this time 
\begin_inset Formula $n$
\end_inset

 equal to the number of vertices in the given mesh.
\end_layout

\begin_layout Subsection
Assembling of the Stiffness matrix and the right-hand side
\end_layout

\begin_layout Standard
The code under consideration is shown below.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for (tri = 0; tri < vertexSize; tri++) { 		
\end_layout

\begin_layout Plain Layout

	for (i = 0; i < 3; i++) { 			
\end_layout

\begin_layout Plain Layout

		globalVertex = (int) *(vertexNumbers + tri * 3 + i) - 1; 			
\end_layout

\begin_layout Plain Layout

		vertices[i][0] = *(meshPoints + globalVertex * 2 + 0); 			
\end_layout

\begin_layout Plain Layout

		vertices[i][1] = *(meshPoints + globalVertex * 2 + 1); 		
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

	localStiffnessMatrix(vertices, localW); 		
\end_layout

\begin_layout Plain Layout

	localVector(vertices, f, localB);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	for (i = 0; i < 3; i++) { 			
\end_layout

\begin_layout Plain Layout

		globalVertex = (int) *(vertexNumbers + tri * 3 + i) - 1; 			
\end_layout

\begin_layout Plain Layout

		b[globalVertex] += localB[i]; 			
\end_layout

\begin_layout Plain Layout

		for (j = 0; j < 3; j++) { 				
\end_layout

\begin_layout Plain Layout

			globalVertex2 = (int) *(vertexNumbers + tri * 3 + j) - 1; 				
\end_layout

\begin_layout Plain Layout

			*(w + globalVertex * meshSize + globalVertex2) += localW[i][j]; 			
\end_layout

\begin_layout Plain Layout

		} 		
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Assembling of the Stiffness matrix and the right-hand side
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The assembling operation is realised by initially calling, for each one
 of the 
\begin_inset Formula $n$
\end_inset

 vertices in the mesh, two functions that compute local elements then summing
 them back to the global ones (the very ones initialised at the previous
 step).
 Since the computation of local elements uses only values at the three vertices
 of the local triangle, its complexity is independent from 
\begin_inset Formula $n$
\end_inset

, and can thus be ignored.
 As a result, we can state that the overall complexity of the assembling
 task is 
\begin_inset Formula $O\left(n\right)$
\end_inset

, i.e.
 linear with respect to the dimension of the mesh.
\end_layout

\begin_layout Subsection
Dirichlet conditions assignment
\end_layout

\begin_layout Standard
At this point, before starting the computation of the solution, we must
 assign particular values to the Stiffness matrix and the right-hand side
 in order to make Dirichlet conditions hold on the boundary of the domain
 under consideration.
 In other words, we have to retrieve those vertices that do belong to the
 boundary of the domain and assign particular values at the correspondent
 positions.
 By looking at the function, whose code implementation is shown below, we
 can easily notice that the number of operations is in the order of 
\begin_inset Formula $n\cdot\left(1+n_{boundary}\right)$
\end_inset

 where 
\begin_inset Formula $n_{boundary}$
\end_inset

 is the number of vertices on the boundary.
 Since, as 
\begin_inset Formula $n$
\end_inset

 grows, this number is much less than the total number 
\begin_inset Formula $n$
\end_inset

, the total number of operations is approximately linear with 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

void assignDirichletCondition(int meshSize, double g, double* meshPoints,
 double* w, double* b) { 	
\end_layout

\begin_layout Plain Layout

	int i, j;
\end_layout

\begin_layout Plain Layout

	for (i = 0; i < meshSize; i++) { 		
\end_layout

\begin_layout Plain Layout

		double x = *(meshPoints + 2 * i); 		
\end_layout

\begin_layout Plain Layout

		double y = *(meshPoints + 2 * i + 1); 		
\end_layout

\begin_layout Plain Layout

		if (fabs(x * x + y * y - 1) < TOL) { 			
\end_layout

\begin_layout Plain Layout

			for (j = 0; j < meshSize; j++) { 				
\end_layout

\begin_layout Plain Layout

				*(w + meshSize * i + j) = (i == j) ? 1 : 0; 			
\end_layout

\begin_layout Plain Layout

			} 			
\end_layout

\begin_layout Plain Layout

			b[i] = g; 		
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Dirichlet conditions assignment
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Computation of the approximate solution
\end_layout

\begin_layout Standard
Finally, with both the matrix and the right-hand side properly assigned,
 it is possible to compute the FEM approximation of the solution 
\begin_inset Formula $u$
\end_inset

.
 Technically speaking, that requires to solve a linear system with 
\begin_inset Formula $n$
\end_inset

 equations in 
\begin_inset Formula $n$
\end_inset

 unknowns.
 This is achieved with two functions that implement the Gaussian Elimination
 algorithm: at first, the whole system is changed with several pivot operations
 till an upper-triangular structure is reached; then, the solutions is computed
 backward.
 The cost for computing the upper triangular system is in the order of 
\begin_inset Formula $\frac{n^{3}}{3}$
\end_inset

 ; the cost for solving the upper triangular system is 
\begin_inset Formula $n^{2}$
\end_inset

 , so that the total asymptotically complexity is 
\begin_inset Formula $O\left(\frac{n^{3}}{3}+n^{2}\right)$
\end_inset

.
 
\end_layout

\begin_layout Standard
As we will see later, this is actually the bottleneck of the whole program.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

double* gaussianElimination(int n, double* matrix, double b[]) {
\end_layout

\begin_layout Plain Layout

	int i, j, k; 	
\end_layout

\begin_layout Plain Layout

	double aux, temp; 	
\end_layout

\begin_layout Plain Layout

	double* x = zeros(n);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/* Gaussian elimination */ 	
\end_layout

\begin_layout Plain Layout

	for (i = 0; i < (n - 1); i++) { 		
\end_layout

\begin_layout Plain Layout

		for (j = (i + 1); j < n; j++) { 			
\end_layout

\begin_layout Plain Layout

			aux = *(matrix + n * j + i) / *(matrix + n * i + i); 			
\end_layout

\begin_layout Plain Layout

			for (k = i; k < n; k++) { 				
\end_layout

\begin_layout Plain Layout

				*(matrix + n * j + k) -= (aux * (*(matrix + n * i + k))); 			
\end_layout

\begin_layout Plain Layout

			} 			
\end_layout

\begin_layout Plain Layout

			b[j] -= (aux * b[i]); 		
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/* Back substitution */ 	
\end_layout

\begin_layout Plain Layout

	x[n - 1] = b[n - 1] / *(matrix + n * (n - 1) + n - 1); 	
\end_layout

\begin_layout Plain Layout

	for (i = (n - 2); i >= 0; i--) { 		
\end_layout

\begin_layout Plain Layout

		temp = b[i]; 		
\end_layout

\begin_layout Plain Layout

		for (j = (i + 1); j < n; j++) { 			
\end_layout

\begin_layout Plain Layout

			temp -= (*(matrix + n * i + j) * x[j]); 		
\end_layout

\begin_layout Plain Layout

		} 		
\end_layout

\begin_layout Plain Layout

		x[i] = temp / *(matrix + n * i + i); 	
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return x; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Computation of the approximate solution
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Profiling of the serial execution
\end_layout

\begin_layout Standard
After this brief study of the theoretical complexity of each one of the
 kernel functions, we shall now analyse the actual results obtained by running
 the code on a computer machine.
 
\end_layout

\begin_layout Standard
Several simulations were run on a Intel i7-2630QM machine to study the computati
on time growth with respect to different mesh dimensions.
 All interesting parameters related to the CPU under consideration are listed
 below.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="2">
<features rotate="0" islongtable="true" headTopDL="true" headBottomDL="true" longtabularalignment="center">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Processor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Intel Core i7-2630QM
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Os architecture
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x64
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Ram memory [Gb]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Clock speed [GHz]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Cores
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Max threads
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
L1 cache
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4x32 KB 8-way-associative
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
L2 cache
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4x256 KB 8-way-associative
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
L3 cache
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 MB 12-way-associative
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
For each function, we computed both the wall clock time, which is the actual
 amount of time taken to perform the job, and the CPU time, which is on
 the other hand the amount of time the function did hold the CPU during
 its execution.
 In order to keep the overhead as light as we could, we avoided the usage
 of professional profiling tools, which by the way usually offer sampling
 frequencies which are completely useless in our case of study.
 Hence, we used instead native functions, in particular 
\family typewriter
omp_get_wtime
\family default
 of 
\family typewriter
omp.h
\family default
 for wall clock time and 
\family typewriter
clock()
\family default
 of 
\family typewriter
time.h
\family default
 for CPU time.
 Both timers has resolutions in the order of microseconds.
\end_layout

\begin_layout Standard
The raw data we collected is shown in the following table.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="7">
<features rotate="0" islongtable="true" headTopDL="true" headBottomDL="true" longtabularalignment="center">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row endhead="true">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Mesh Size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Overall
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
IO
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Initialisation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Assembling
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Dirichlet
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Gaussian Elimination
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000080
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000123
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000014
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000023
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000003
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000051
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
33
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000151
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000143
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000032
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000042
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000004
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000100
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
41
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000232
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000171
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000036
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000034
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000005
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000188
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
75
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.001117
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000153
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000033
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000063
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.001030
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
144
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.006962
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000283
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000109
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000125
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000020
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.006774
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
544
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.354619
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000901
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.004083
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000672
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000139
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.353258
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2173
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
22.964478
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.002509
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.023644
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.003044
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000954
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
22.951455
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3447
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
97.154916
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.004003
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.048192
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.004370
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.001921
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
97.125484
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6084
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
513.562017
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.007300
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.150833
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.007964
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.004399
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
513.480326
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13693
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5563.750536
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.015359
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.754177
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.018652
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.014815
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5563.298515
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Since the simulations were run minimising the number of concurrent jobs,
 we notice that the wall clock time and CPU time do not actually differ
 too much.
 Hence, from now on we will consider just the CPU time measurement, indeed
 more significant.
\end_layout

\begin_layout Standard
To better understand the results, we plotted for each function both the
 expected trend and the real one; moreover, to highlight asymptotic complexity,
 we also provided log-log scale plots.
 
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename image/zeros.eps
	width 100text%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Initialisation.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename image/assembling.eps
	width 100text%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Assembling.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename image/dirichlet.eps
	width 100text%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Dirichlet condition assignment.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename image/gauss.eps
	width 100text%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Gaussian elimination (theoretical prediction is almost perfectly overlapped
 to simulation)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Parallelization study
\end_layout

\begin_layout Section
Parallel implementation
\end_layout

\begin_layout Section
Profiling of the parallel execution
\end_layout

\begin_layout Standard
Like we did for the serial execution, we shall now proceed analysing the
 execution of the parallel code on computer machines.
 The profiling operation were made in the exact same way of the serial one,
 but simulations were run on different machines in order to study the speed-up
 of parallel code with respect to the number of available cores.
 All interesting parameters related to the processors under consideration
 are listed below.
\end_layout

\begin_layout Section
Result analysis
\end_layout

\begin_layout Section
A bit of insight
\end_layout

\end_body
\end_document
