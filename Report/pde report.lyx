#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\use_default_options true
\begin_modules
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language british
\language_package auto
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2.5cm
\rightmargin 2cm
\bottommargin 2.5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "language=C,keywordstyle={\color{cyan}},commentstyle={\color{magenta}\itshape},emphstyle={\color{blue}},emph={int,char,double,float,unsigned},breaklines=true,basicstyle={\ttfamily},stringstyle={\color{green}},identifierstyle={\color{black}},numbers=left,numbersep=3pt,tabsize=2"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Finite Elements Methods: a parallel implementation
\end_layout

\begin_layout Author
Simone Colucci & Emanuele Fabbiani
\end_layout

\begin_layout Date
February 
\begin_inset Formula $15^{th}$
\end_inset

, 2016
\end_layout

\begin_layout Abstract
TODO
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Partial differential equations (PDE) are differential equations where the
 unknown is a multivariable function.
 Far from being just complex mathematical problems, PDE are very useful
 tools to model several different phenomena in Physics, Biology, Economics
 and Engineering.
 Maxwell's laws of Electromagnetic fields and Navier-Stokes equations for
 fluids are just two examples of major applications of PDE theory.
 However, PDEs are usually impossible to solve in closed form: numerical
 methods are required to compute approximate solutions.
 The most used methods to solve PDE numerically are known as Finite Element
 Methods.
 First introduced in the '40s FEMs utility was underestimated at the time
 because of the lack of computational power.
 Nowadays they enter the design process of planes, buildings and cars as
 a low-cost and effective alternative to real stress tests.
\end_layout

\begin_layout Subsection
The Finite Element Method
\end_layout

\begin_layout Standard
To understand how the method works, we consider an elliptic homogeneous
 equation:
\begin_inset Formula 
\begin{equation}
\begin{cases}
-\Delta u\left(x,y\right)=f\left(x,y\right) & in\:\Omega\\
u=g\left(x,y\right) & on\:\partial\Omega
\end{cases}
\end{equation}

\end_inset

where 
\begin_inset Formula $\Delta u\left(x,y\right)=\frac{\partial^{2}u\left(x,y\right)}{\partial x^{2}}+\frac{\partial^{2}u\left(x,y\right)}{\partial y^{2}}$
\end_inset

 and 
\begin_inset Formula $f:\mathbb{R}^{2}\mapsto\mathbb{R}$
\end_inset

 is a well-defined function in 
\begin_inset Formula $\Omega\in\mathbb{R}^{2}$
\end_inset

.
 FEMs are based on the weak formulation of the differential problem, so
 we have to introduce a test function 
\begin_inset Formula $v$
\end_inset

, which is supposed to be regular enough.
 We multiply the differential equation by 
\begin_inset Formula $v$
\end_inset

 and we integrate over 
\begin_inset Formula $\Omega$
\end_inset

:
\begin_inset Formula 
\begin{equation}
\int_{\Omega}\left(-\Delta u\right)v=\int_{\Omega}fv
\end{equation}

\end_inset

Then we apply the Gauss-Green formula:
\begin_inset Formula 
\begin{equation}
\int_{\Omega}\Delta uv+\int_{\Omega}\nabla u\cdot\nabla v=\int_{\partial\Omega}v\frac{\partial u}{\partial n}
\end{equation}

\end_inset

And we choose 
\begin_inset Formula $v$
\end_inset

 such that 
\begin_inset Formula $v|_{\partial\Omega}\equiv0$
\end_inset

.
 We got to the weak formulation:
\begin_inset Formula 
\begin{equation}
\int_{\Omega}\nabla u\cdot\nabla v=\int_{\partial\Omega}v\frac{\partial u}{\partial n}+\int_{\Omega}fv
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
\int_{\Omega}\nabla u\cdot\nabla v=\int_{\Omega}fv\label{eq:debole}
\end{equation}

\end_inset

This equation should hold for every 
\begin_inset Formula $v$
\end_inset

.
 Up to here, no approximation has been performed.
 Form now on, the Finite Elements approximation begins.
 We approximate the set 
\begin_inset Formula $\Omega$
\end_inset

 with the union of triangles 
\begin_inset Formula $\mathcal{T}_{h}$
\end_inset

.
\begin_inset Formula 
\begin{equation}
\Omega\simeq\bigcup_{T\in\mathcal{T}_{h}}T
\end{equation}

\end_inset

The equality holds only if 
\begin_inset Formula $\Omega$
\end_inset

 is a polygon.
 The length 
\begin_inset Formula $h$
\end_inset

 of the longest edge of a triangle 
\begin_inset Formula $T\in\mathcal{T}_{h}$
\end_inset

 is a good index about how fine the mesh is.
 Then we approximate the function 
\begin_inset Formula $u$
\end_inset

 with a new function 
\begin_inset Formula $u_{h}$
\end_inset

, which is supposed to be linear on every triangle 
\begin_inset Formula $T$
\end_inset

 and continuous on 
\begin_inset Formula $\Omega$
\end_inset

; moreover we want the test function 
\begin_inset Formula $v$
\end_inset

 to present the same features.
 To underline the restriction, 
\begin_inset Formula $v$
\end_inset

 will be called 
\begin_inset Formula $v_{h}$
\end_inset

.
 It is possible to show that the functional space 
\begin_inset Formula $u_{h}$
\end_inset

 and 
\begin_inset Formula $v_{h}$
\end_inset

 belong to has a dimension which is finite and equals the number 
\begin_inset Formula $n$
\end_inset

 of vertexes of triangles in the internal of the set 
\begin_inset Formula $\Omega$
\end_inset

.
 We define 
\begin_inset Formula $\varphi_{i}$
\end_inset

, 
\begin_inset Formula $i=1...n$
\end_inset

 a set of functions which is a basis for the functional space 
\begin_inset Formula $v$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

 belongs to:
\begin_inset Formula 
\begin{equation}
u_{h}\left(x,y\right)=\sum_{i=1}^{n}u_{i}\varphi_{i}\left(x,y\right)
\end{equation}

\end_inset

The equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:debole"

\end_inset

 is verified by every 
\begin_inset Formula $v$
\end_inset

 if and only if it holds for all the elements 
\begin_inset Formula $\varphi_{j}$
\end_inset

 in a basis of the functional space.
 We impose this condition and we get to the following linear system:
\begin_inset Formula 
\begin{equation}
\sum_{i=1}^{n}u_{i}\int_{\Omega}\nabla\varphi_{i}\cdot\nabla\varphi_{j}=\int_{\Omega}f\cdot\varphi_{j}\;\;\forall j=1...n
\end{equation}

\end_inset

We define 
\begin_inset Formula $W=\left\{ W_{i,j}\right\} =\int_{\Omega}\nabla\varphi_{i}\cdot\nabla\varphi_{j}$
\end_inset

, 
\begin_inset Formula $u=\left\{ u_{i}\right\} $
\end_inset

 and 
\begin_inset Formula $b=\left\{ b_{j}\right\} \coloneqq\int_{\Omega}f\cdot\varphi_{j}$
\end_inset

, so that we can write the system in matrix form:
\begin_inset Formula 
\begin{equation}
Wu=b
\end{equation}

\end_inset

We can exploit the linearity of the integral to ease the computation of
 
\begin_inset Formula $W$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

: we can compute the contribution on every triangle 
\begin_inset Formula $T$
\end_inset

 and then sum them up.
 We choose the easiest set of basic functions 
\begin_inset Formula $\varphi$
\end_inset

, that is the 
\begin_inset Formula $\varphi_{j}=1$
\end_inset

 on the vertex with index 
\begin_inset Formula $j$
\end_inset

 and 0 on all the others.
 The computation of the local matrix 
\begin_inset Formula $W_{T}$
\end_inset

 of the triangle 
\begin_inset Formula $T$
\end_inset

 lead to a symmetric matrix:
\begin_inset Formula 
\begin{equation}
W_{T}=\begin{bmatrix}\int_{\Omega}\nabla\varphi_{i}\cdot\nabla\varphi_{i} & \int_{\Omega}\nabla\varphi_{i}\cdot\nabla\varphi_{j} & \int_{\Omega}\nabla\varphi_{i}\cdot\nabla\varphi_{k}\\
\int_{\Omega}\nabla\varphi_{i}\cdot\nabla\varphi_{j} & \int_{\Omega}\nabla\varphi_{j}\cdot\nabla\varphi_{j} & \int_{\Omega}\nabla\varphi_{j}\cdot\nabla\varphi_{k}\\
\int_{\Omega}\nabla\varphi_{i}\cdot\nabla\varphi_{k} & \int_{\Omega}\nabla\varphi_{j}\cdot\nabla\varphi_{k} & \int_{\Omega}\nabla\varphi_{k}\cdot\nabla\varphi_{k}
\end{bmatrix}=\frac{1}{4\left|T\right|}\begin{bmatrix}l_{i}\cdot l_{i} & l_{i}\cdot l_{j} & l_{i}\cdot l_{k}\\
l_{j}\cdot l_{i} & l_{j}\cdot l_{j} & l_{j}\cdot l_{k}\\
l_{k}\cdot l_{i} & l_{k}\cdot l_{j} & l_{k}\cdot l_{k}
\end{bmatrix}
\end{equation}

\end_inset

where 
\begin_inset Formula $\left|T\right|$
\end_inset

 is the area of the triangle and 
\begin_inset Formula $l_{i}\cdot l_{j}$
\end_inset

 is the scalar product between the edges described by the vectors 
\begin_inset Formula $l_{i}$
\end_inset

 and 
\begin_inset Formula $l_{j}$
\end_inset

.
 We can compute the local right-hand side 
\begin_inset Formula $b_{T}$
\end_inset

, using some quadrature formula.
 We choose the barycentre formula, the easiest one:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
b_{T}=\begin{bmatrix}\int_{\Omega}f\cdot\varphi_{i}\\
\int_{\Omega}f\cdot\varphi_{j}\\
\int_{\Omega}f\cdot\varphi_{k}
\end{bmatrix}\simeq\frac{\left|T\right|}{3}\begin{bmatrix}f\left(x_{B},y_{B}\right)\\
f\left(x_{B},y_{B}\right)\\
f\left(x_{B},y_{B}\right)
\end{bmatrix}
\end{equation}

\end_inset

dove
\begin_inset Formula 
\begin{equation}
x_{B}=\frac{1}{3}\sum_{i=1}^{3}x_{i}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
y_{B}=\frac{1}{3}\sum_{i=1}^{3}y_{i}
\end{equation}

\end_inset

It can be proved that this formula is exact if and only if the function
 
\begin_inset Formula $f$
\end_inset

 is constant on the border of 
\begin_inset Formula $\Omega$
\end_inset

.
\end_layout

\begin_layout Subsection
Model problem
\end_layout

\begin_layout Standard
We take the following partial differential equation as a model:
\begin_inset Formula 
\begin{equation}
\begin{cases}
-\Delta u\left(x,y\right)=-4 & in\:\Omega=\left\{ \left(x,y\right)\in\mathbb{R}^{2}:x^{2}+y^{2}\leq1\right\} \\
u=1 & on\:\partial\Omega=\left\{ \left(x,y\right)\in\mathbb{R}^{2}:x^{2}+y^{2}=1\right\} 
\end{cases}
\end{equation}

\end_inset

We choose this very equation because we can deduce the true solution.
 If we try 
\begin_inset Formula 
\begin{equation}
u\left(x,y\right)=x^{2}+y^{2}
\end{equation}

\end_inset

we get:
\begin_inset Formula 
\begin{equation}
-\Delta u\left(x,y\right)=-\frac{\partial^{2}u\left(x,y\right)}{\partial x^{2}}-\frac{\partial^{2}u\left(x,y\right)}{\partial y^{2}}=-2-2=-4
\end{equation}

\end_inset

As the solution to such a problem is proved to be unique, 
\begin_inset Formula $u\left(x,y\right)$
\end_inset

 is the function we are looking for.
\end_layout

\begin_layout Section
Serial Implementation
\end_layout

\begin_layout Standard
vinfcviepvcmepvmpemvpemvcop
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

double* zeros(int dim) { 	
\end_layout

\begin_layout Plain Layout

	int i = 0;
\end_layout

\begin_layout Plain Layout

	double* vector = (double*) malloc(sizeof(double) * dim); 	
\end_layout

\begin_layout Plain Layout

	for (i = 0; i < dim; i++) { 		
\end_layout

\begin_layout Plain Layout

		vector[i] = 0; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	return vector; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Zeros() TODO!!
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

double* gaussianElimination(int n, double* matrix, double b[]) {
\end_layout

\begin_layout Plain Layout

	int i, j, k; 	
\end_layout

\begin_layout Plain Layout

	double aux, temp; 	
\end_layout

\begin_layout Plain Layout

	double* x = zeros(n);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/* Gaussian elimination */ 	
\end_layout

\begin_layout Plain Layout

	for (i = 0; i < (n - 1); i++) { 		
\end_layout

\begin_layout Plain Layout

		for (j = (i + 1); j < n; j++) { 			
\end_layout

\begin_layout Plain Layout

			aux = *(matrix + n * j + i) / *(matrix + n * i + i); 			
\end_layout

\begin_layout Plain Layout

			for (k = i; k < n; k++) { 				
\end_layout

\begin_layout Plain Layout

				*(matrix + n * j + k) -= (aux * (*(matrix + n * i + k))); 			
\end_layout

\begin_layout Plain Layout

			} 			
\end_layout

\begin_layout Plain Layout

			b[j] -= (aux * b[i]); 		
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/* Back substitution */ 	
\end_layout

\begin_layout Plain Layout

	x[n - 1] = b[n - 1] / *(matrix + n * (n - 1) + n - 1); 	
\end_layout

\begin_layout Plain Layout

	for (i = (n - 2); i >= 0; i--) { 		
\end_layout

\begin_layout Plain Layout

		temp = b[i]; 		
\end_layout

\begin_layout Plain Layout

		for (j = (i + 1); j < n; j++) { 			
\end_layout

\begin_layout Plain Layout

			temp -= (*(matrix + n * i + j) * x[j]); 		
\end_layout

\begin_layout Plain Layout

		} 		
\end_layout

\begin_layout Plain Layout

		x[i] = temp / *(matrix + n * i + i); 	
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return x; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
GEM() TODO!!
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for (tri = 0; tri < vertexSize; tri++) { 		
\end_layout

\begin_layout Plain Layout

	for (i = 0; i < 3; i++) { 			
\end_layout

\begin_layout Plain Layout

		globalVertex = (int) *(vertexNumbers + tri * 3 + i) - 1; 			
\end_layout

\begin_layout Plain Layout

		vertices[i][0] = *(meshPoints + globalVertex * 2 + 0); 			
\end_layout

\begin_layout Plain Layout

		vertices[i][1] = *(meshPoints + globalVertex * 2 + 1); 		
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

	localStiffnessMatrix(vertices, localW); 		
\end_layout

\begin_layout Plain Layout

	localVector(vertices, f, localB);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	for (i = 0; i < 3; i++) { 			
\end_layout

\begin_layout Plain Layout

		globalVertex = (int) *(vertexNumbers + tri * 3 + i) - 1; 			
\end_layout

\begin_layout Plain Layout

		b[globalVertex] += localB[i]; 			
\end_layout

\begin_layout Plain Layout

		for (j = 0; j < 3; j++) { 				
\end_layout

\begin_layout Plain Layout

			globalVertex2 = (int) *(vertexNumbers + tri * 3 + j) - 1; 				
\end_layout

\begin_layout Plain Layout

			*(w + globalVertex * meshSize + globalVertex2) += localW[i][j]; 			
\end_layout

\begin_layout Plain Layout

		} 		
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
ASSEMBLING() TODO!!
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

void assignDirichletCondition(int meshSize, double g, double* meshPoints,
 double* w, double* b) { 	
\end_layout

\begin_layout Plain Layout

	int i, j;
\end_layout

\begin_layout Plain Layout

	for (i = 0; i < meshSize; i++) { 		
\end_layout

\begin_layout Plain Layout

		double x = *(meshPoints + 2 * i); 		
\end_layout

\begin_layout Plain Layout

		double y = *(meshPoints + 2 * i + 1); 		
\end_layout

\begin_layout Plain Layout

		if (fabs(x * x + y * y - 1) < TOL) { 			
\end_layout

\begin_layout Plain Layout

			for (j = 0; j < meshSize; j++) { 				
\end_layout

\begin_layout Plain Layout

				*(w + meshSize * i + j) = (i == j) ? 1 : 0; 			
\end_layout

\begin_layout Plain Layout

			} 			
\end_layout

\begin_layout Plain Layout

			b[i] = g; 		
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
DIRICHLET() TODO!!
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
